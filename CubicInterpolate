using UnityEngine;
using System.Collections;

public class CubicInterpolate : MonoBehaviour {
	
	float[] x={1.4f,3f,4f,5.5f,6.5f,7.4f};
	float[] y={2.3f,4.4f,5.6f,8f,10f,10.4f};
	float[][] cubicP;
	float[] xExt;
	float[] yExt;
	Vector2[] p;
	Vector3[] pd;


	// Use this for initialization
	void OnDrawGizmos()
	{
	//	for(int i=0;i<5;i++){
	//	Gizmos.DrawLine(new Vector2(x[i],y[i]),new Vector2(x[i+1],y[i+1]));
	//	}
		for(int i=0;i<6;i++){
			Gizmos.DrawSphere(new Vector2(x[i],y[i]),0.1f);
		}
		for(int i=0;i<xExt.Length-1;i++){
			Gizmos.DrawLine(new Vector2(xExt[i],yExt[i]),new Vector2(xExt[i+1],yExt[i+1]));
		}
	}
	void Start () {
		cubicP=Cinterp(x,y);
		xExt=Xinterp(x,cubicP[4],4);
		yExt=Yinterp(xExt,4,cubicP[0],cubicP[1],cubicP[2],cubicP[3]);
	}
	
	// Update is called once per frame
	void Update () {
	
	}
	static float[] TDMA(float [] ta,float [] tb,float [] tc, float [] tx)
	{
		int n=tx.Length;
		tc[0]=tc[0]/tb[0];
		tx[0]=tx[0]/tb[0];

		for(int i=1;i<n;i++){
			float m=1/(tb[i]-ta[i]*tc[i-1]);
			tc[i]=tc[i]*m;
			tx[i]=(tx[i]-ta[i]*tx[i-1])*m;
		}
		for(int i=n-2;i>0;i--)
		{
			tx[i]=tx[i]-tc[i]*tx[i+1];
		}
		return tx;
	}
	
	private float[][] Cinterp(Vector2[] p)
	{
		float[] x=new float[p.Length];
		float[] y=new float[p.Length];

		for(int i=0;i<p.Length;i++)
		{
			x[i]=p[i].x;
			y[i]=p[i].y;
		}
		return Cinterp(x,y);
	}
	private float[][] Cinterp(float[] x, float[] y)
	{
		int n=x.Length;
		float[] m=new float[n];
		float[] h=new float[n-1];
		float[] a=new float[n];
		float[] b=new float[n];
		float[] c=new float[n];
		float[] d=new float[n];
		float[][] result=new float[5][];
		for(int i=0;i<n-1;i++)
		{
			h[i]=x[i+1]-x[i];
		}
		a[0]=0;
		b[0]=1;
		c[0]=0;
		d[0]=0;
		a[n-1]=0;
		b[n-1]=1;
		c[n-1]=0;
		d[n-1]=0;
		for(int i=1;i<n-1;i++)
		{
			a[i]=h[i-1];
			b[i]=2*(h[i-1]+h[i]);
			c[i]=h[i];
			d[i]=6*((y[i+1]-y[i])/h[i]-(y[i]-y[i-1])/h[i-1]);
		}
		m=TDMA(a,b,c,d);
		for(int i=0;i<n-1;i++)
		{
			a[i]=y[i];
			b[i]=(y[i+1]-y[i])/h[i]-h[i]*m[i]/2-h[i]*(m[i+1]-m[i])/6;
			c[i]=m[i]/2;
			d[i]=(m[i+1]-m[i])/(6*h[i]);
		}
		result[0]=a;
		result[1]=b;
		result[2]=c;
		result[3]=d;
		result[4]=h;
		return result;

	}
	private float[] Xinterp(float[] xin,float[] hin,int divide)
	{
		float[] xExt=new float[(xin.Length-1)*divide+1];
		int i=0;
		for(;i<(xin.Length-1);i++)
		{
			for(int j=0;j<divide;j++)
			{
			xExt[i*divide+j]=xin[i]+hin[i]/3*j;
			}
		}	
		xExt[i*divide]=xin[i];
		return xExt;
	}
	private float[] Yinterp(float[] xex,int divide,float[] a,float[] b,float[] c,float[] d)
	{
		float[] yout=new float[xex.Length];
		int i=0;
		for(;i<xex.Length;i++)
		{
			int seg=(int)i/divide;
			float h=xex[i]-xex[seg*divide];
			yout[i]=a[seg]+b[seg]*h+c[seg]*h*h+d[seg]*h*h*h;
		}
		yout[xex.Length-1]=y[y.Length-1];
		return yout;
	}
	public float[] OneStepCubic(Vector2 x1,Vector2 x2)
	{
		float[] abcd=new float[4];
		abcd[0]=x1.y;
		abcd[3]=(x2.y-x1.y)/Mathf.Pow((x2.x-x1.x),3);
		return abcd;
		//在两点之间画一个自然边界条件的三次插值曲线
	}
}
